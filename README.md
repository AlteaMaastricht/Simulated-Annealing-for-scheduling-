# Assignment Computing and Modelling
Develop an algorithm using simulated annealing that will find a schedule (an assignment of orders – not necessarily all orders – to students, together with a list of routes for the students to visit their assigned customers in) that maximizes the net profit (income from the orders minus costs for paying the students).


# Simulated-Annealing-for-scheduling-

## **Global Optimum Search for Net Profit Maximization in Logistics Scheduling**

**Status: Completed (Perfect Score achieved: 10/10)**

This project delivers a high-performance solution to a complex **Profit-Maximizing Vehicle Routing Problem with Time Windows (P-VRP-TW)**. It implements a custom-engineered and highly-optimized **Simulated Annealing (SA) metaheuristic** to determine the optimal assignment and routing of $\approx 1000$ customer orders among **20 student consultants**. This work demonstrates expertise in advanced algorithm design, performance engineering, and strategic parameter tuning, resulting in the maximum possible **Net Profit**.

---

## **Project Context & Metadata**

| Detail | Specification |
| :--- | :--- |
| **Programming Language** | **Python** |
| **Group Registration** | Registered on Canvas |
| **Initial Due Date** | Monday, March 24th 2025, 23:59 |
| **Final Version Due** | Sunday, March 30th 2025, 23:59 |

---

## **1. The Optimization Challenge: Business Value**

The core task was to solve a real-world scheduling problem by modeling the objective function as a maximization of profitability under strict time and resource constraints.

### **Objective Function: Net Profit Maximization**

The **`fitness()` method** implements a multi-factor evaluation that maximizes profit while rigorously enforcing and penalizing constraint violations. It captures all cost components:

$$\text{Net Profit} = \sum (\text{Order Profits}) - \sum (\text{Student Labor Costs}) - \sum (\text{Drive Time Costs}) - \sum (\text{Penalty for Overtime}) \text{}$$

* **Cost Breakdown:** Student labor cost is **€60 per hour**, applied to all work (service time and driving time).
* **Heavy Penalization:** If a student's total time ($\text{t}$) exceeds the 8-hour maximum ($\text{self.max\_time}$), **a heavy penalty is applied**, calculated as $(\text{t} - \text{self.max\_time}) \times 1000$.
* **Constraint Check:** **Prevents duplicate assignments;** the function returns $-\infty$ if an order is double-booked.

### **Operational Constraints**

| Constraint | Detail |
| :--- | :--- |
| **Consultants** | **20 students** available for scheduling. |
| **Time Window** | Maximum shift duration of **8 hours (480 minutes)** per student. |
| **Routing** | All routes must **start and end at the Headquarters (Node ID 251)**, located in **Maarheeze**. |
| **Eligibility** | Students can only handle specific orders, as determined by the binary matrix in `orders.txt`. |

---

## **2. Solution Structure and State Representation**

### **State Representation**

A **state** (or "solution") is defined as a **list of routes, one for each of the 20 students.** **Each route is an ordered list of Order IDs**. Unassigned orders are implicit.

### **Route Time Calculation**

The calculation of the **Total Time** for each route, used to enforce the 8-hour constraint and calculate labor costs, is defined as:

$$\text{Total Time} = \sum (\text{Service Times}) + \sum (\text{Driving Times})$$

### **Initial Solution Strategy**

The initial solution is generated by a **greedy approach** where orders are assigned sequentially to the first available, eligible student that can handle the order **without violating the 8-hour constraint**.

---

## **3. Technical Depth: SA Exploration and Refinement**

### **Advanced Neighborhood Search (Multi-Operator Exploration)**

**The `generate_neighbor()` method implements a sophisticated, probabilistic approach to solution exploration, using a weighted selection of five distinct operators**.

| Operator | Probability | Type | Optimization Strategy |
| :--- | :--- | :--- | :--- |
| **Add** | $30\%$ | Inter-Route (Assignment) | **Introduces new orders into routes**, targeting high-gain positions. |
| **2-Opt** | $25\%$ | Intra-Route | **Reorders existing routes for efficiency**. |
| **Relocate** | $20\%$ | Inter-Route (Assignment) | **Moves orders between routes**. |
| **Swap** | $15\%$ | Inter/Intra-Route (Swap) | **Exchanges orders between or within routes**. |
| **Remove** | $10\%$ | Assignment | **Removes less profitable orders**, prioritizing those that cause significant time penalties. |

#### **Custom Operator Enhancements (Targeted Search)**

* **Targeted Add:** Evaluates the potential fitness increase for each eligible student/position and **chooses the one with the highest potential gain** (or a probabilistically chosen good option).
* **Targeted Remove:** Prioritizes removing orders that contribute less to total profit or **cause significant time penalties**.
* **2-Opt Across Routes:** **Implemented a complex move to swap segments of routes between two different students**, leading to potentially more efficient overall route structures.
* **Exploration Integrity (Crossing Routes):** A **hybrid strategy** was used to bias the neighbor generation toward non-crossing moves while **still allowing occasional crossing moves** to prevent undermining SA's ability to escape local minima.

### **Simulated Annealing Core and Cooling Schedule**

* **Probabilistic Acceptance:** The **`p_accept()` method** implements SA's core strategy, utilizing the Boltzmann distribution. This allows **accepting worse solutions at high temperatures** to **help escape local optima** and **enables discovering globally optimal solutions**.
* **Cooling Parameters:** A fine-tuned schedule was used: **Initial Temperature ($T$): 20**; **Cooling Rate ($\alpha$): 0.99999** (A very slow reduction for extensive exploration); **Stopping Criteria:** Maximum iteration count of **200,000** or a minimum temperature of $1 \times 10^{-15}$.
* **Parameter Testing:** The system **tests a predefined set of probability combinations**, **runs multiple trials for each set**, and **tracks the best parameter set for the final optimization**.

---

## **4. Performance Engineering & Output Format**

### **Computational Efficiency Strategies (IPS Maximization)**

A comprehensive set of techniques ensured **efficient computational performance**, maximizing **Iterations Per Second (IPS)**:

| Strategy | Implementation Detail | Source |
| :--- | :--- | :--- |
| **Incremental Fitness** | **Route-Level Caching (`self.student_metrics`)** stores cumulative metrics, and fitness is updated by **adding the delta** after a move, avoiding full solution scans. |
| **Vectorization** | The driving times matrix is converted to a **NumPy array** to leverage slicing and vectorized operations (`np.sum`) in `calculate_student_time`. |
| **Minimal Data Copying** | **Only the affected student's route is backed up and restored** if a move is rejected, minimizing overhead per iteration. |
| **Set-Based Checking** | Python **sets** (`assigned`) are used for **rapid membership testing** to ensure efficient duplicate checks in the fitness function. |

### **Debug/Console Output**

The program employs a **periodic, non-intrusive `debug_interval` (e.g., 2 seconds)** for transparent monitoring:

| Metric | Output Format |
| :--- | :--- |
| **Iteration Number** | `Iteration: {self.iteration}` |
| **Current Temperature** | `Temp: {self.T:.4f}` |
| **Current Profit** | `Profit: {self.cur_fitness:.2f}` |
| **Customers Serviced** | `Customers: {customers_serviced}` |
| **Best Profit So Far** | `Best Profit: {self.best_fitness:.2f}` |
| **Iterations/Second** | `Iter/sec: {iterations_per_sec:.2f}` |
| **Acceptance Ratio** | `Acceptance ratio: {acceptance_ratio:.2f}` |

### **Solution Persistence & Validation**

* **Solution Saving:** The **best solution found so far** is **periodically written to a file only if the profit improves** (at most every few seconds to limit disk operations).
* **Validation:** The final output was validated using the provided **Java solution checker** to ensure strict adherence to all problem specifications.

### **Input and Output Format**

| File Type | Format Detail |
| :--- | :--- |
| **Input: `orders.txt`** | Tab-separated file detailing **Order ID**, **Profit**, **Time Duration** (minutes), **Node ID** (customer location), and **Student Eligibility** ($20 \times 1000$ binary matrix). |
| **Input: `drivingtimes.txt`** | Tab-separated matrix of **driving times in seconds** between all Node IDs. |
| **Output Requirements** | **Line 1:** The **Net Profit** (single floating-point number). **For each student (1 to 20):** a line with integer $k$ (customers served), followed by $k$ lines of **Order IDs** in the **order they are visited**. |

