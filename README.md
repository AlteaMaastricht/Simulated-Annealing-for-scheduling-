# Assignment Computing and Modelling
Develop an algorithm using simulated annealing that will find a schedule (an assignment of orders – not necessarily all orders – to students, together with a list of routes for the students to visit their assigned customers in) that maximizes the net profit (income from the orders minus costs for paying the students).


# Simulated-Annealing-for-scheduling-

## **Global Optimum Search for Net Profit Maximization in Logistics Scheduling**

**Status: Completed (Perfect Score achieved: 10/10)**

This project delivers a high-performance solution to a complex **Profit-Maximizing Vehicle Routing Problem with Time Windows (P-VRP-TW)**. It implements a custom-engineered and highly-optimized **Simulated Annealing (SA)** metaheuristic to determine the optimal assignment and routing of $\approx 1000$ customer orders among 20 student consultants. This work demonstrates expertise in advanced algorithm design, performance engineering, and strategic parameter tuning, resulting in the maximum possible **Net Profit**.

---

## **Project Context & Metadata**

| Detail | Specification |
| :--- | :--- |
| **Programming Language** | **Python** |
| **Group Registration** | Registered on Canvas |
| **Initial Due Date** | Monday, March 24th 2025, 23:59 |
| **Final Version Due** | Sunday, March 30th 2025, 23:59 |

---

## **1. The Optimization Challenge: Business Value**

The core task was to solve a real-world business scheduling problem by modeling the objective function as a maximization of profitability under strict time and resource constraints.

### **Objective Function: Net Profit Maximization**

The **`fitness()` method** implements a multi-factor evaluation that maximizes profit while rigorously enforcing and penalizing constraint violations. It captures all cost components:

$$\text{Net Profit} = \sum (\text{Order Profits}) - \sum (\text{Student Labor Costs}) - \sum (\text{Drive Time Costs}) - \sum (\text{Penalty for Overtime}) \text{}$$

* **Cost Breakdown:** Student labor cost is **€60 per hour**, applied to all work (service time and driving time).
* **Heavy Penalization:** If a student's total time ($\text{t}$) exceeds the 8-hour maximum ($\text{self.max\_time}$), a heavy penalty is applied, calculated as $(\text{t} - \text{self.max\_time}) \times 1000$.
* **Constraint Check:** Prevents duplicate assignments; returns $-\infty$ if an order is double-booked.

### **Operational Constraints**

| Constraint | Detail |
| :--- | :--- |
| **Consultants** | **20 students** available for scheduling. |
| **Time Window** | Maximum shift duration of **8 hours (480 minutes)** per student. |
| **Routing** | All routes must **start and end at the Headquarters (Node ID 251)**, located in **Maarheeze**. |
| **Eligibility** | Order assignment must adhere to student-specific skills/eligibility, detailed in the binary matrix in `orders.txt`. |

---

## **2. Solution Structure and State Representation**

### **State Representation**

A **state** (or "solution") is defined as a list of routes, one for each of the 20 students. **Each route is an ordered list of Order IDs**. Unassigned orders are implicit.

### **Route Time Calculation**

A key component of the evaluation is the calculation of the **Total Time** for each route, used to enforce the 8-hour constraint and calculate labor costs:

$$\text{Total Time} = \sum (\text{Service Times}) + \sum (\text{Driving Times})$$

### **Initial Solution Strategy**

The initial solution is generated by:

* **[Greedy Approach Example]:** A greedy approach where orders are assigned sequentially to the first available, eligible student that can handle the order **without violating the 8-hour constraint**. This provides a strong, feasible starting point for the SA search.

---

## **3. Technical Depth: SA Exploration and Refinement**

### **Advanced Neighborhood Search (Multi-Operator Exploration)**

The **`generate_neighbor()` method** uses a probabilistic, multi-operator approach.

| Operator | Probability | Type | Optimization Strategy |
| :--- | :--- | :--- | :--- |
| **Add** | $30\%$ | Inter-Route (Assignment) | Introduces new orders into routes, targeting high-gain positions. |
| **2-Opt** | $25\%$ | Intra-Route | Reorders existing routes for efficiency. |
| **Relocate** | $20\%$ | Inter-Route (Assignment) | Moves orders between routes, or from the unassigned pool. |
| **Swap** | $15\%$ | Inter/Intra-Route (Swap) | Exchanges orders between or within routes. |
| **Remove** | $10\%$ | Assignment | Removes less profitable or high-cost orders. |

### **Simulated Annealing Core and Cooling Schedule**

* **Probabilistic Acceptance:** The **`p_accept()` method** utilizes the Boltzmann distribution to allow accepting worse solutions at high temperatures to escape local optima.
* **Cooling Schedule:** A **geometric** cooling schedule was employed.
    * **Initial Temperature ($T_0$): 20**
    * **Cooling Rate ($\alpha$): 0.99999** (A very slow reduction for extensive exploration).
    * **Stopping Criterion:** A maximum iteration count of **200,000** or a minimum temperature of $1 \times 10^{-15}$.

---

## **4. Performance Engineering & Output Format**

### **Computational Efficiency Strategies (IPS Maximization)**

Key techniques ensure a high **Iterations Per Second (IPS)**: **Incremental Fitness Calculation (Route-Level Caching)**, **Vectorization (NumPy)**, **Minimal Data Copying**, and **Set-Based Checking** for constraints.

### **Debug/Console Output**

The program provides **periodic console output (every few seconds)** for transparent monitoring:

| Metric | Description |
| :--- | :--- |
| **Iteration Number** | The current SA iteration. |
| **Current Temperature** | The current temperature $T$. |
| **Current Profit** | Net profit of the solution at the current iteration. |
| **Customers Serviced** | Total number of orders assigned in the current solution. |
| **Best Profit So Far** | The highest net profit found since the start. |
| **Iterations/Second** | The average speed of the algorithm. |
| **Acceptance Ratio** | The ratio of accepted vs. rejected neighborhood operations. |

### **Solution Persistence & Validation**

* **Solution Saving:** The **best solution found so far** is periodically written to a file **only if the profit improves** (at most every few seconds to limit disk operations).
* **Validation:** The final output was validated using the provided **Java solution checker** to ensure strict adherence to all problem specifications.

### **Input and Output Format**

| File Type | Format Detail |
| :--- | :--- |
| **Input: `orders.txt`** | Tab-separated file detailing **Order ID**, **Profit**, **Time Duration** (minutes), **Node ID** (customer location), and **Student Eligibility** ($20 \times 1000$ binary matrix). |
| **Input: `drivingtimes.txt`** | Tab-separated matrix of **driving times in seconds** between all Node IDs. |
| **Output Requirements** | **Line 1:** The **Net Profit**. **For each student (1 to 20):** a line with integer $k$ (customers served), followed by $k$ lines of **Order IDs** in the **order they are visited**. |
